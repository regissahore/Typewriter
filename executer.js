// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Executer = (function() {
    function Executer(canvas) {
      this.canvas = canvas;
      this.execute = __bind(this.execute, this);
      this.applyPen = __bind(this.applyPen, this);
      this.applyBackground = __bind(this.applyBackground, this);
      this.toRgb = __bind(this.toRgb, this);
      this.context = this.canvas.getContext('2d');
      this.width = this.canvas.width;
      this.height = this.canvas.height;
      this.x = this.width * 0.5;
      this.y = this.height * 0.5;
      this.angle = Math.PI * 0.5;
      this.background = [0, 0, 0];
      this.pen = {
        colour: [255, 255, 255],
        width: 1,
        down: true
      };
      this.applyBackground();
      this.applyPen();
    }

    Executer.prototype.toRgb = function(data) {
      return 'rgb(' + data[0] + ',' + data[1] + ',' + data[2] + ')';
    };

    Executer.prototype.applyBackground = function() {
      this.context.beginPath;
      this.context.fillStyle = this.toRgb(this.background);
      this.context.strokeStyle = this.toRgb(this.background);
      this.context.fillRect(0, 0, this.width, this.height);
      return this.context.endPath;
    };

    Executer.prototype.applyPen = function() {
      this.context.strokeStyle = this.toRgb(this.pen.colour);
      return this.context.strokeWidth = this.pen.width;
    };

    Executer.prototype.execute = function(instructions) {
      var instruction, length, rotate, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = instructions.length; _i < _len; _i++) {
        instruction = instructions[_i];
        switch (instruction.keyword) {
          case 'FORWARD':
          case 'FD':
            if (this.pen.down) {
              this.context.moveTo(this.x, this.y);
            }
            length = parseFloat(instruction.parameter[0]);
            this.x += length * Math.cos(this.angle);
            this.y -= length * Math.sin(this.angle);
            if (this.pen.down) {
              this.context.lineTo(this.x, this.y);
              _results.push(this.context.stroke());
            } else {
              _results.push(void 0);
            }
            break;
          case 'BACK':
          case 'BK':
            if (this.pen.down) {
              this.context.moveTo(this.x, this.y);
            }
            length = parseFloat(instruction.parameter[0]);
            this.x -= length * Math.cos(this.angle);
            this.y += length * Math.sin(this.angle);
            if (this.pen.down) {
              this.context.lineTo(this.x, this.y);
              _results.push(this.context.stroke());
            } else {
              _results.push(void 0);
            }
            break;
          case 'LEFT':
          case 'LT':
            rotate = parseFloat(instruction.parameter[0]);
            _results.push(this.angle += rotate * Math.PI / 180.0);
            break;
          case 'RIGHT':
          case 'RT':
            rotate = parseFloat(instruction.parameter[0]);
            _results.push(this.angle -= rotate * Math.PI / 180.0);
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    return Executer;

  })();

}).call(this);
