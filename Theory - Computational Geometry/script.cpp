#include <cmath> \n#include <cstdio> \n#include <cstring> \n#include <stack> \n#include <vector> \n#include <algorithm> \nusing namespace std; \nconst double EPS = 1e-8; \nconst double PI = acos(-1.0); \n \nint dblcmp(double x) \n{ \n    if (fabs(x) < EPS) \n    { \n        return 0; \n    } \n    return x > 0 ? 1 : -1; \n} \n \nstruct Point \n{ \n    double x, y; \n    Point() \n    { \n        x = 0.0; \n        y = 0.0; \n    } \n    Point(double x, double y) \n    { \n        this->x = x; \n        this->y = y; \n    } \n    inline double length() const \n    { \n        return sqrt(x * x + y * y); \n    } \n}; \n \nPoint operator -(const Point &a, const Point &b) \n{ \n    Point c; \n    c.x = a.x - b.x; \n    c.y = a.y - b.y; \n    return c; \n} \n \ndouble operator *(const Point &a, const Point &b) \n{ \n    return a.x * b.x + a.y * b.y; \n} \n \ndouble operator ^(const Point &a, const Point &b) \n{ \n    return a.x * b.y - a.y * b.x; \n} \n \ndouble cross(const Point &a, const Point &b, const Point &o) \n{ \n    return (a - o) ^ (b - o); \n} \n \ndouble dist(const Point &a, const Point &b) \n{ \n    return (a - b).length(); \n} \n \ndouble rotatingCalipers(vector<Point> &points) \n{ \n    double ans = 0.0; \n    points.push_back(points[0]); \n    for (int i = 0, j = 1; i < points.size(); ++i) \n    { \n        while (fabs(cross(points[i], points[i + 1], points[j + 1])) > \n               fabs(cross(points[i], points[i + 1], points[j]))) \n        { \n            j = (j + 1) % (points.size() - 1); \n        } \n        ans = max(ans, max(dist(points[i], points[j]), dist(points[i + 1], points[j]))); \n    } \n    return ans; \n} \n \nint main() \n{ \n    vector<Point> points; \n    points.push_back(Point(-2, -9)); \n    points.push_back(Point(6, -6)); \n    points.push_back(Point(8, 2)); \n    points.push_back(Point(7, 7)); \n    points.push_back(Point(-1, 6)); \n    points.push_back(Point(-5, 5)); \n    points.push_back(Point(-9, -4)); \n    points.push_back(Point(-2, -9)); \n    printf(\"%.3lf\\n\", rotatingCalipers(points)); \n    return 0; \n} \n