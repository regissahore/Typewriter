#include <cmath> \n#include <cstdio> \n#include <cstring> \n#include <stack> \n#include <vector> \n#include <algorithm> \nusing namespace std; \nconst double EPS = 1e-8; \nconst double PI = acos(-1.0); \n \nint dblcmp(double x) \n{ \n    if (fabs(x) < EPS) \n    { \n        return 0; \n    } \n    return x > 0 ? 1 : -1; \n} \n \nstruct Point \n{ \n    double x, y; \n    Point() \n    { \n        x = 0.0; \n        y = 0.0; \n    } \n    Point(double x, double y) \n    { \n        this->x = x; \n        this->y = y; \n    } \n    inline void input() \n    { \n        scanf(\"%lf%lf\", &x, &y); \n    } \n    inline void output() const \n    { \n        printf(\"%.3lf %.3lf\\n\", x, y); \n    } \n    bool operator <(const Point &point) const \n    { \n        if (y == point.y) \n        { \n            return x < point.x; \n        } \n        return y < point.y; \n    } \n}; \n \nPoint operator -(const Point &a, const Point &b) \n{ \n    Point c; \n    c.x = a.x - b.x; \n    c.y = a.y - b.y; \n    return c; \n} \n \ndouble operator *(const Point &a, const Point &b) \n{ \n    return a.x * b.x + a.y * b.y; \n} \n \ndouble operator ^(const Point &a, const Point &b) \n{ \n    return a.x * b.y - a.y * b.x; \n} \n \ndouble cross(const Point &a, const Point &b, const Point &o) \n{ \n    return (a - o) ^ (b - o); \n} \n \nstruct Polygon \n{ \n    vector<Point> vertex; \n    inline void output() \n    { \n        for (size_t i = 0; i < vertex.size(); ++i) \n        { \n            vertex[i].output(); \n        } \n    } \n}; \n \nvoid graham(vector<Point> &points, Polygon &convex) \n{ \n    convex.vertex.clear(); \n    sort(points.begin(), points.end()); \n    convex.vertex.push_back(points[0]); \n    convex.vertex.push_back(points[1]); \n    for (size_t i = 2; i < points.size(); ++i) \n    { \n        while (convex.vertex.size() >= 2) \n        { \n            if (dblcmp((points[i] - convex.vertex[convex.vertex.size() - 1]) ^ (convex.vertex[convex.vertex.size() - 1] - convex.vertex[convex.vertex.size() - 2])) <= 0) \n            { \n                break; \n            } \n            convex.vertex.pop_back(); \n        } \n        convex.vertex.push_back(points[i]); \n    } \n    convex.vertex.push_back(points[points.size() - 2]); \n    int top = convex.vertex.size(); \n    for (int i = points.size() - 3; i >= 0; --i) \n    { \n        while (convex.vertex.size() >= top) \n        { \n            if (dblcmp((points[i] - convex.vertex[convex.vertex.size() - 1]) ^ (convex.vertex[convex.vertex.size() - 1] - convex.vertex[convex.vertex.size() - 2])) <= 0) \n            { \n                break; \n            } \n            convex.vertex.pop_back(); \n        } \n        convex.vertex.push_back(points[i]); \n    } \n} \n \nint main() \n{ \n    vector<Point> points; \n    points.push_back(Point(1, 2)); \n    points.push_back(Point(4, -4)); \n    points.push_back(Point(-5, 5)); \n    points.push_back(Point(-3, -8)); \n    points.push_back(Point(-2, -9)); \n    points.push_back(Point(8, 2)); \n    points.push_back(Point(-9, -4)); \n    points.push_back(Point(6, -6)); \n    points.push_back(Point(4, -2)); \n    points.push_back(Point(7, 7)); \n    points.push_back(Point(-1, 6)); \n    Polygon polygon; \n    graham(points, polygon); \n    polygon.output(); \n    return 0; \n} \n